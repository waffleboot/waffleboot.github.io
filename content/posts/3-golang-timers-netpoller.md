---
title: "Golang таймеры и netpoller"
date: 2021-08-05T00:56:22+03:00
draft: false
---

Прикольно. timer работает в связке с netpoller. Все таймеры кладутся в heap (структура данных) чтобы выбрать ближайший, при этом у каждого P свой heap. netpoller так-то заточен под asyncio, но блокирующий epoll syscall вызывается с таймаутом по ближайший таймер. Понятно, если придет io event, он проснется, выдаст пачку файловых дескрипторов и снова уснет, но время сна скорректируется. А если по таймауту проснется - дергаем таймер.

Самое интересное, когда добавляем таймер который должен тикнуть раньше времени таймаута netpoller. Надо будить netpoller и давать новый таймаут. Для этого у netpoller есть netpollBreakRd/Wr, это два файловых дескриптора из pipe(). Создание такого таймера приводит в конечном счете к записи байта в netpollBreakWr и netpoller просыпается потому что есть что читать. Читает мусорный байт и выставляет новое время сна. Кажется так. Это конечно случай когда есть epoll.

Таймеры освобождаются сами, но если таймаут происходит редко, то таймеры будут болтаться долго, а они *относительно* тяжелые. Короче, их хорошо бы t.Stop()
