<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on yangand</title><link>https://waffleboot.github.io/posts/</link><description>Recent content in Posts on yangand</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Aug 2021 02:38:04 +0300</lastBuildDate><atom:link href="https://waffleboot.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Как tcp находит свой сокет</title><link>https://waffleboot.github.io/posts/17-inet-lookup/</link><pubDate>Fri, 20 Aug 2021 02:38:04 +0300</pubDate><guid>https://waffleboot.github.io/posts/17-inet-lookup/</guid><description>Сетевой стек linux содержит 4 хэш-таблицы:
ehash для установленных соединений bhash для bind lhash2 для listen соединение как вида addr:port, так и any_addr:port listening_hash как простое хранилище listen-сокетов linux listen socket lookup</description></item><item><title>Git Reflog</title><link>https://waffleboot.github.io/posts/16-git-reflog/</link><pubDate>Fri, 20 Aug 2021 01:05:06 +0300</pubDate><guid>https://waffleboot.github.io/posts/16-git-reflog/</guid><description>TL;DR: to restore git history
git reflog master git reset --hard @{1} git reflog git все изменения в refs (ссылках) пишет в логи .git/logs/
Например, изменения в HEAD (или .git/HEAD) пишутся в .git/logs/HEAD
Обычно git reflog показывает только историю HEAD
4939906 HEAD@{0}: checkout: moving from test to master 494e06a HEAD@{1}: checkout: moving from master to test 4939906 HEAD@{2}: checkout: moving from 379e743595f56cb0b4177fd248c84c47523a4e6b to master 379e743 HEAD@{3}: checkout: moving from master to 379e743595f56cb0b4177fd248c84c47523a4e6b 4939906 HEAD@{4}: clone: from https://github.</description></item><item><title>git reflog</title><link>https://waffleboot.github.io/posts/15-git-reflog/</link><pubDate>Tue, 17 Aug 2021 23:24:31 +0300</pubDate><guid>https://waffleboot.github.io/posts/15-git-reflog/</guid><description>Git Reflog should be your friend</description></item><item><title>netpoll</title><link>https://waffleboot.github.io/posts/14-linux-netpoll/</link><pubDate>Tue, 17 Aug 2021 15:13:17 +0300</pubDate><guid>https://waffleboot.github.io/posts/14-linux-netpoll/</guid><description>The implementaion of epoll part 1
part 2
part 3
part 4
Application of epoll in golang
Deep analysis of source code for building native network model with go netpol I / O multiplexing
Detailed Golang Net NetPoll
Golang underlay NetPoll
Detailed Golang Net Transport
Talk about Golang NetPoll Principles (1)
Talk about the netpoll principle of golang (2)
Golang Net HTTP Server
epoll - from the kernel side</description></item><item><title>Linux eBPF</title><link>https://waffleboot.github.io/posts/13-linux-ebpf/</link><pubDate>Tue, 17 Aug 2021 14:02:22 +0300</pubDate><guid>https://waffleboot.github.io/posts/13-linux-ebpf/</guid><description>Linux source code elixir
woboq
LiveGrep
Probes and tracepoints bpftrace
bpftrace Reference Guide
kprobes
tracepoints
bcc reference guide
brendan gregg linux perf
The art of writing eBPF programs: a primer.
Posts How to turn any syscall into an event
Debugging the eBPF Virtual Machine video
opensnoop sample
Getting started with Linux kernel development
Tracing a packet journey using Linux tracepoints, perf and eBPF
Linux insides Модули ядра Linux
linux-insides book</description></item><item><title>Good design</title><link>https://waffleboot.github.io/posts/12-good-design/</link><pubDate>Mon, 16 Aug 2021 14:39:20 +0300</pubDate><guid>https://waffleboot.github.io/posts/12-good-design/</guid><description>Good design should not allow using our code in an invalid way.</description></item><item><title>Anti-Patterns in Go Web</title><link>https://waffleboot.github.io/posts/11-common-anti-patterns/</link><pubDate>Sat, 14 Aug 2021 14:39:20 +0300</pubDate><guid>https://waffleboot.github.io/posts/11-common-anti-patterns/</guid><description>Common Anti-Patterns in Go Web Applications от threedots
The important part is not how you split them but how they’re connected. Go is supposed to be simple, but it doesn’t mean you should use only primitive types. Be explicit, even if it’s verbose. еще статья про монолиты и микросервисы и Clean Arch</description></item><item><title>checklist</title><link>https://waffleboot.github.io/posts/10-check-list/</link><pubDate>Thu, 12 Aug 2021 21:13:52 +0300</pubDate><guid>https://waffleboot.github.io/posts/10-check-list/</guid><description>чеклист
В коде Установлены таймауты на обращения ко всем внешним сервисам, ретраи - опционально Для простых REST-запросов &amp;ldquo;обычный&amp;rdquo; таймаут (на всю операцию) Для скачивания/загрузки файлов (и других поточных запросов) &amp;ldquo;динамический&amp;rdquo; таймаут (на один блок в потоке) Для бесшовного деплоя сервисов, обрабатывающих http-запросы, настроена пауза между получением сигнала (SIGINT, SIGTERM) и отключением приема соединений. &amp;lt;тут линк на страницу, где было исследование&amp;gt;. Если есть подключение к СУБД - установлен лимит на количество подключений Рекомендация: именованные подключения к СУБД (для postgres пример: postgresql://other@localhost/otherdb?</description></item><item><title>Avito messenger</title><link>https://waffleboot.github.io/posts/8-avito-messenger/</link><pubDate>Wed, 11 Aug 2021 04:40:32 +0300</pubDate><guid>https://waffleboot.github.io/posts/8-avito-messenger/</guid><description>Архитектура Мессенджера Авито – путь одного сообщения
2,5 млн уников в день 1,5 млн rpm rpc запросов к бэку 500k постоянных соединений онлайн в пике websocket 7k msg/m rabbitmq mongodb redis k8s websocket
json-rpc
server-socket
http-polling (http fallback)
stripe.com/rate-limiters
service-aggregator (+graceful degradation)
сначала сохранение сообщения только в шард отправителя публикация событий в rabbitmq rabbitmq отказоустойчивый кластер из двух машин
настроены политики отказоустойчивости для exchange и очередей</description></item><item><title>Golang Trace</title><link>https://waffleboot.github.io/posts/7-golang-trace/</link><pubDate>Tue, 10 Aug 2021 12:15:17 +0300</pubDate><guid>https://waffleboot.github.io/posts/7-golang-trace/</guid><description>это программа
func main() { f, err := os.Create(&amp;quot;trace.out&amp;quot;) if err != nil { log.Fatal(err) } defer f.Close() if err := trace.Start(f); err != nil { log.Fatal(err) } go func() { // runtime.PreemptNS(1000) for { _x++ } }() &amp;lt;-time.After(3 * time.Second) runtime.GC() defer trace.Stop() } это содержимое trace.out при запуске с GOMAXPROCS=1
// сначала идет список горутин на момент запуска trace.Start // G1 в статусе running, остальные в статусе waiting потому что P у нас только один 1: GoCreate /Users/yangand/Workspace/go_infinite_loop/main.</description></item><item><title>Golang Naming</title><link>https://waffleboot.github.io/posts/5-golang-naming/</link><pubDate>Sat, 07 Aug 2021 10:17:07 +0300</pubDate><guid>https://waffleboot.github.io/posts/5-golang-naming/</guid><description>for _, tt := range tests { } Смысл в удваивании имени переменной когда итерируем по слайсу. Это применяется в тестах.
tests := []struct { give string wantHost string wantPort string }{ { give: &amp;quot;&amp;quot;, wantHost: &amp;quot;&amp;quot;, wantPort: &amp;quot;&amp;quot;, }, } for _, tt := range tests { t.Run(tt.give, func(t *testing.T) { host, port, err := net.SplitHostPort(tt.give) require.NoError(t, err) assert.Equal(t, tt.wantHost, host) assert.Equal(t, tt.wantPort, port) }) }</description></item><item><title>GopherAcademy Blog</title><link>https://waffleboot.github.io/posts/4-gopher-academy-blog/</link><pubDate>Thu, 05 Aug 2021 01:14:40 +0300</pubDate><guid>https://waffleboot.github.io/posts/4-gopher-academy-blog/</guid><description>GopherAcademy blog</description></item><item><title>Golang таймеры и netpoller</title><link>https://waffleboot.github.io/posts/3-golang-timers-netpoller/</link><pubDate>Thu, 05 Aug 2021 00:56:22 +0300</pubDate><guid>https://waffleboot.github.io/posts/3-golang-timers-netpoller/</guid><description>Прикольно. timer работает в связке с netpoller. Все таймеры кладутся в heap (структура данных) чтобы выбрать ближайший, при этом у каждого P свой heap. netpoller так-то заточен под asyncio, но блокирующий epoll syscall вызывается с таймаутом по ближайший таймер. Понятно, если придет io event, он проснется, выдаст пачку файловых дескрипторов и снова уснет, но время сна скорректируется. А если по таймауту проснется - дергаем таймер.
Самое интересное, когда добавляем таймер который должен тикнуть раньше времени таймаута netpoller.</description></item><item><title>Про параметры функции, публикуемых в открытый доступ</title><link>https://waffleboot.github.io/posts/2-api-config/</link><pubDate>Thu, 05 Aug 2021 00:40:05 +0300</pubDate><guid>https://waffleboot.github.io/posts/2-api-config/</guid><description>Изучал код worker пула https://github.com/ahmetask/worker и там есть такая функция NewWorkerPool(maxWorkers, jobQueueCapacity):
func NewWorkerPool(maxWorkers int, jobQueueCapacity int) *Pool Я предложил сделать отдельную структуру под конфигурацию workerPoolConfig и worker пул иницилизировать не через параметры, а через функциональные опции, через &amp;hellip;Opts. Добавить функцию buildWorkerPoolConfig, которая бы эти &amp;hellip;Opts читала и создавала конфиг, дополнительно валидируя параметры. Заслал PR, чел отказался фиксить по причине, что сломается обратная совместимость, а либа и так простая, так что нет смысла.</description></item></channel></rss>