<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>yangand</title><link>https://waffleboot.github.io/</link><description>Recent content on yangand</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Dec 2021 07:09:34 +0300</lastBuildDate><atom:link href="https://waffleboot.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Ram Disk</title><link>https://waffleboot.github.io/posts/28-ram-disk/</link><pubDate>Wed, 01 Dec 2021 07:09:34 +0300</pubDate><guid>https://waffleboot.github.io/posts/28-ram-disk/</guid><description>RAM disk на 1Гб
2097152 = 2048 * 1024
diskutil erasevolume HFS+ &amp;quot;RAMDisk&amp;quot; `hdiutil attach -nomount ram://2097152`</description></item><item><title>protobuf</title><link>https://waffleboot.github.io/posts/27-protobuf/</link><pubDate>Mon, 15 Nov 2021 15:11:51 +0300</pubDate><guid>https://waffleboot.github.io/posts/27-protobuf/</guid><description>Пытаюсь понять как работает grpc-gateway
syntax = &amp;quot;proto3&amp;quot;; import &amp;quot;google/api/annotations.proto&amp;quot;; service Service { rpc Method(Request) returns (Response) { option (google.api.http) = { post: &amp;quot;/endpoint&amp;quot; body: &amp;quot;*&amp;quot; }; } } Оказывается:
protoc это компилятор и содержит parser.cc, который парсит .proto файлы и option поначалу выгрызает как строку, как uninterpreted_option затем работает DescriptorBuilder и он эту строку парсит и превращает в message и проставляет полученный message в http поле поэтому в grpc-gateway плагин приходит описание без uninterpreted_option, а в виде описания опции метода, которое содержит поле http а это поле http появляется там из-за механизма extension annotations.</description></item><item><title>Про Go интерфейсы</title><link>https://waffleboot.github.io/posts/26-go-interfaces/</link><pubDate>Fri, 12 Nov 2021 14:34:31 +0300</pubDate><guid>https://waffleboot.github.io/posts/26-go-interfaces/</guid><description>модули должны обладать:
высокой специализацей низкой связностью с другими модулями один пакет знает только про интерфейс второй про интерфейс ничего не знает, а только его реализует описываются там где используются должны содержать только то, что используется Целью интерфейсов является ограничить распространение сложности, иначе может быть отравление кода сложностью базы данных.
&amp;ldquo;Маленькое копирование лучше маленькой связности&amp;rdquo;
Поэтому нет ничего страшного в том, чтобы скопировать интерфейс в кучу мест, а не тянуть зависимость по модулям.</description></item><item><title>Про обратную связь на code review</title><link>https://waffleboot.github.io/posts/25-code-review/</link><pubDate>Wed, 20 Oct 2021 15:21:48 +0300</pubDate><guid>https://waffleboot.github.io/posts/25-code-review/</guid><description>Нужно уметь доводить обратную связь. Это умение не у всех есть. Профессинально давать обратную связь. Обратную связь дает профессионал, которого этому научили.
Принцип бутерброда (&amp;ldquo;сэндвич с дерьмом&amp;rdquo;)
хорошо плохо хорошо в zoom поднимать руку, не перебивать
очень трудно найти грань в обратной связи: донести мысль, но не испортить отношения
code review:
это не код человека, с которым ты общаешься по остальным вопросам это как если бы мне прислали его с вопросом все ли в нем нормально, т.</description></item><item><title>на поизучать Go</title><link>https://waffleboot.github.io/posts/25-go-learn-main-http/</link><pubDate>Sat, 09 Oct 2021 01:16:41 +0300</pubDate><guid>https://waffleboot.github.io/posts/25-go-learn-main-http/</guid><description>Проекты на поизучать как устроены реальные main и http handlers в проектах на Го:
gitea grafana mattermost hugo</description></item><item><title>git merge conflict</title><link>https://waffleboot.github.io/posts/24-git-merge-conflict/</link><pubDate>Wed, 15 Sep 2021 01:16:41 +0300</pubDate><guid>https://waffleboot.github.io/posts/24-git-merge-conflict/</guid><description>git режет изменения на блоки и если два блока соседствуют, то будет конфликт, если же блоки разделяет общая линия, то конфликта не будет и слияние будет автоматическим
пример где есть неизменная линия master test description 1 изначально в файле только 1 12 добавили 2 123 добавили 3 1123 1233 в master поменяли первую строчку, в test поменяли последнюю 11233 git merge testслилось автомическит.</description></item><item><title>visual studio code shortcuts</title><link>https://waffleboot.github.io/posts/23-visual-studio-code/</link><pubDate>Tue, 14 Sep 2021 11:57:43 +0300</pubDate><guid>https://waffleboot.github.io/posts/23-visual-studio-code/</guid><description>General Command Shortcut Command Palette (aka &amp;ldquo;&amp;gt;&amp;quot;) F1 or Shift + Cmd + P Go to File &amp;hellip; Cmd + P Settings Cmd + , Basic editing Command Shortcut Cut line Cmd + X Copy line Cmd + C Copy line up/down Shift + Option + Up/Down Multiple cursors Cmd + Shift + L or Option Click Multi-cursor and selection Command Shortcut Expand / Shrink selection Ctrl + Shift + Cmd + Left/Right Search and replace Command Shortcut Add selection to next Find match Cmd + D</description></item><item><title>git cherry pick</title><link>https://waffleboot.github.io/posts/22-git-cherry-pick/</link><pubDate>Wed, 08 Sep 2021 14:30:00 +0300</pubDate><guid>https://waffleboot.github.io/posts/22-git-cherry-pick/</guid><description>Несколько версий продукта в Git
git cherry-pick это команда по копированию коммитов. Каждый коммит внутри git это некоторое состояние проекта, а cherry-pick вычисляет разницу (по сути каждый коммит это разница между состояниями) и применяет эту разницу в нужной ветке. В вышеуказанном видео упоминается git cherry-pick -m который позволяет скопировать merge-коммит в нужную ветку. Есть master, от него отпочковывается ветка, в ней идет разработка, несколько коммитов, потом эти коммиты сливаются в master и надо например все эти коммиты перенести в следующие ветки.</description></item><item><title>Errors in Go 1.13</title><link>https://waffleboot.github.io/posts/21-errors-in-go/</link><pubDate>Mon, 30 Aug 2021 02:38:04 +0300</pubDate><guid>https://waffleboot.github.io/posts/21-errors-in-go/</guid><description>Errors in Go 1.13 Whether to Wrap When adding additional context to an error, either with fmt.Errorf or by implementing a custom type, you need to decide whether the new error should wrap the original. There is no single answer to this question; it depends on the context in which the new error is created. Wrap an error to expose it to callers. Do not wrap an error when doing so would expose implementation details.</description></item><item><title>Golang interfaces</title><link>https://waffleboot.github.io/posts/20-golang-interfaces/</link><pubDate>Mon, 30 Aug 2021 02:38:04 +0300</pubDate><guid>https://waffleboot.github.io/posts/20-golang-interfaces/</guid><description>if x, ok := obj.(interface{ MyMethod(int) bool }); ok &amp;amp;&amp;amp; x.MyMethod(42) { ... } Т.е. можно определять интерфейс на лету если он используется только в одной точке. Но и проверку на соответствие интерфейсу наружу тоже не вынести.
type MyInterface interface { MyMethod(int) bool }</description></item><item><title>C++ code style</title><link>https://waffleboot.github.io/posts/19-code-style/</link><pubDate>Sun, 22 Aug 2021 02:38:04 +0300</pubDate><guid>https://waffleboot.github.io/posts/19-code-style/</guid><description>google style guide
types typedef using enum nested structs and classes constants factory functions constructors assignment operators destructor all other methods data members</description></item><item><title>Python scons build tool</title><link>https://waffleboot.github.io/posts/18-python-scons-mongo/</link><pubDate>Fri, 20 Aug 2021 02:38:04 +0300</pubDate><guid>https://waffleboot.github.io/posts/18-python-scons-mongo/</guid><description>scons-man</description></item><item><title>Как tcp находит свой сокет</title><link>https://waffleboot.github.io/posts/17-inet-lookup/</link><pubDate>Fri, 20 Aug 2021 02:38:04 +0300</pubDate><guid>https://waffleboot.github.io/posts/17-inet-lookup/</guid><description>Сетевой стек linux содержит 4 хэш-таблицы для быстрого поиска сокета для входящего пакета:
ehash для установленных соединений bhash для bind lhash2 для listen соединение как вида addr:port, так и any_addr:port listening_hash как простое хранилище listen-сокетов linux listen socket lookup
Размер ehash таблицы регулируется параметром thash_entries. The default is 65536 entries for every gigabyte of memory. In other words, an 8-gigabyte system will have 512k hash entries. Но этого более чем достаточно.</description></item><item><title>Git Reflog</title><link>https://waffleboot.github.io/posts/16-git-reflog/</link><pubDate>Fri, 20 Aug 2021 01:05:06 +0300</pubDate><guid>https://waffleboot.github.io/posts/16-git-reflog/</guid><description>TL;DR: to restore git history
git reflog master git reset --hard @{1} git reflog git все изменения в refs (ссылках) пишет в логи .git/logs/
Например, изменения в HEAD (или .git/HEAD) пишутся в .git/logs/HEAD
Обычно git reflog показывает только историю HEAD
4939906 HEAD@{0}: checkout: moving from test to master 494e06a HEAD@{1}: checkout: moving from master to test 4939906 HEAD@{2}: checkout: moving from 379e743595f56cb0b4177fd248c84c47523a4e6b to master 379e743 HEAD@{3}: checkout: moving from master to 379e743595f56cb0b4177fd248c84c47523a4e6b 4939906 HEAD@{4}: clone: from https://github.</description></item><item><title>git reflog</title><link>https://waffleboot.github.io/posts/15-git-reflog/</link><pubDate>Tue, 17 Aug 2021 23:24:31 +0300</pubDate><guid>https://waffleboot.github.io/posts/15-git-reflog/</guid><description>Git Reflog should be your friend</description></item><item><title>netpoll</title><link>https://waffleboot.github.io/posts/14-linux-netpoll/</link><pubDate>Tue, 17 Aug 2021 15:13:17 +0300</pubDate><guid>https://waffleboot.github.io/posts/14-linux-netpoll/</guid><description>The implementaion of epoll part 1
part 2
part 3
part 4
Application of epoll in golang
Deep analysis of source code for building native network model with go netpol I / O multiplexing
Detailed Golang Net NetPoll
Golang underlay NetPoll
Detailed Golang Net Transport
Talk about Golang NetPoll Principles (1)
Talk about the netpoll principle of golang (2)
Golang Net HTTP Server
epoll - from the kernel side</description></item><item><title>Linux eBPF</title><link>https://waffleboot.github.io/posts/13-linux-ebpf/</link><pubDate>Tue, 17 Aug 2021 14:02:22 +0300</pubDate><guid>https://waffleboot.github.io/posts/13-linux-ebpf/</guid><description>Linux source code elixir
woboq
LiveGrep
Probes and tracepoints bpftrace
bpftrace Reference Guide
kprobes
tracepoints
bcc reference guide
brendan gregg linux perf
The art of writing eBPF programs: a primer.
Posts How to turn any syscall into an event
Debugging the eBPF Virtual Machine video
opensnoop sample
Getting started with Linux kernel development
Tracing a packet journey using Linux tracepoints, perf and eBPF
Linux insides Модули ядра Linux
linux-insides book</description></item><item><title>Good design</title><link>https://waffleboot.github.io/posts/12-good-design/</link><pubDate>Mon, 16 Aug 2021 14:39:20 +0300</pubDate><guid>https://waffleboot.github.io/posts/12-good-design/</guid><description>Good design should not allow using our code in an invalid way.</description></item><item><title>Anti-Patterns in Go Web</title><link>https://waffleboot.github.io/posts/11-common-anti-patterns/</link><pubDate>Sat, 14 Aug 2021 14:39:20 +0300</pubDate><guid>https://waffleboot.github.io/posts/11-common-anti-patterns/</guid><description>Common Anti-Patterns in Go Web Applications от threedots
The important part is not how you split them but how they’re connected. Go is supposed to be simple, but it doesn’t mean you should use only primitive types. Be explicit, even if it’s verbose. еще статья про монолиты и микросервисы и Clean Arch</description></item><item><title>checklist</title><link>https://waffleboot.github.io/posts/10-check-list/</link><pubDate>Thu, 12 Aug 2021 21:13:52 +0300</pubDate><guid>https://waffleboot.github.io/posts/10-check-list/</guid><description>чеклист
В коде Установлены таймауты на обращения ко всем внешним сервисам, ретраи - опционально Для простых REST-запросов &amp;ldquo;обычный&amp;rdquo; таймаут (на всю операцию) Для скачивания/загрузки файлов (и других поточных запросов) &amp;ldquo;динамический&amp;rdquo; таймаут (на один блок в потоке) Для бесшовного деплоя сервисов, обрабатывающих http-запросы, настроена пауза между получением сигнала (SIGINT, SIGTERM) и отключением приема соединений. &amp;lt;тут линк на страницу, где было исследование&amp;gt;. Если есть подключение к СУБД - установлен лимит на количество подключений Рекомендация: именованные подключения к СУБД (для postgres пример: postgresql://other@localhost/otherdb?</description></item><item><title>Avito messenger</title><link>https://waffleboot.github.io/posts/8-avito-messenger/</link><pubDate>Wed, 11 Aug 2021 04:40:32 +0300</pubDate><guid>https://waffleboot.github.io/posts/8-avito-messenger/</guid><description>Архитектура Мессенджера Авито – путь одного сообщения
2,5 млн уников в день 1,5 млн rpm rpc запросов к бэку 500k постоянных соединений онлайн в пике websocket 7k msg/m rabbitmq mongodb redis k8s websocket
json-rpc
server-socket
http-polling (http fallback)
stripe.com/rate-limiters
service-aggregator (+graceful degradation)
сначала сохранение сообщения только в шард отправителя публикация событий в rabbitmq rabbitmq отказоустойчивый кластер из двух машин
настроены политики отказоустойчивости для exchange и очередей</description></item><item><title>Golang Trace</title><link>https://waffleboot.github.io/posts/7-golang-trace/</link><pubDate>Tue, 10 Aug 2021 12:15:17 +0300</pubDate><guid>https://waffleboot.github.io/posts/7-golang-trace/</guid><description>это программа
func main() { f, err := os.Create(&amp;quot;trace.out&amp;quot;) if err != nil { log.Fatal(err) } defer f.Close() if err := trace.Start(f); err != nil { log.Fatal(err) } go func() { // runtime.PreemptNS(1000) for { _x++ } }() &amp;lt;-time.After(3 * time.Second) runtime.GC() defer trace.Stop() } это содержимое trace.out при запуске с GOMAXPROCS=1
// сначала идет список горутин на момент запуска trace.Start // G1 в статусе running, остальные в статусе waiting потому что P у нас только один 1: GoCreate /Users/yangand/Workspace/go_infinite_loop/main.</description></item><item><title>Golang Naming</title><link>https://waffleboot.github.io/posts/5-golang-naming/</link><pubDate>Sat, 07 Aug 2021 10:17:07 +0300</pubDate><guid>https://waffleboot.github.io/posts/5-golang-naming/</guid><description>for _, tt := range tests { } Смысл в удваивании имени переменной когда итерируем по слайсу. Это применяется в тестах.
tests := []struct { give string wantHost string wantPort string }{ { give: &amp;quot;&amp;quot;, wantHost: &amp;quot;&amp;quot;, wantPort: &amp;quot;&amp;quot;, }, } for _, tt := range tests { t.Run(tt.give, func(t *testing.T) { host, port, err := net.SplitHostPort(tt.give) require.NoError(t, err) assert.Equal(t, tt.wantHost, host) assert.Equal(t, tt.wantPort, port) }) }</description></item><item><title>GopherAcademy Blog</title><link>https://waffleboot.github.io/posts/4-gopher-academy-blog/</link><pubDate>Thu, 05 Aug 2021 01:14:40 +0300</pubDate><guid>https://waffleboot.github.io/posts/4-gopher-academy-blog/</guid><description>GopherAcademy blog</description></item><item><title>Golang таймеры и netpoller</title><link>https://waffleboot.github.io/posts/3-golang-timers-netpoller/</link><pubDate>Thu, 05 Aug 2021 00:56:22 +0300</pubDate><guid>https://waffleboot.github.io/posts/3-golang-timers-netpoller/</guid><description>Прикольно. timer работает в связке с netpoller. Все таймеры кладутся в heap (структура данных) чтобы выбрать ближайший, при этом у каждого P свой heap. netpoller так-то заточен под asyncio, но блокирующий epoll syscall вызывается с таймаутом по ближайший таймер. Понятно, если придет io event, он проснется, выдаст пачку файловых дескрипторов и снова уснет, но время сна скорректируется. А если по таймауту проснется - дергаем таймер.
Самое интересное, когда добавляем таймер который должен тикнуть раньше времени таймаута netpoller.</description></item><item><title>Про параметры функции, публикуемых в открытый доступ</title><link>https://waffleboot.github.io/posts/2-api-config/</link><pubDate>Thu, 05 Aug 2021 00:40:05 +0300</pubDate><guid>https://waffleboot.github.io/posts/2-api-config/</guid><description>Изучал код worker пула https://github.com/ahmetask/worker и там есть такая функция NewWorkerPool(maxWorkers, jobQueueCapacity):
func NewWorkerPool(maxWorkers int, jobQueueCapacity int) *Pool Я предложил сделать отдельную структуру под конфигурацию workerPoolConfig и worker пул иницилизировать не через параметры, а через функциональные опции, через &amp;hellip;Opts. Добавить функцию buildWorkerPoolConfig, которая бы эти &amp;hellip;Opts читала и создавала конфиг, дополнительно валидируя параметры. Заслал PR, чел отказался фиксить по причине, что сломается обратная совместимость, а либа и так простая, так что нет смысла.</description></item></channel></rss>